import { 
  AIImageProvider, 
  ImageGenerationConfig, 
  ImageGenerationResponse,
  GeneratedImageData 
} from './types';

// Mock provider for local development to reduce API costs
export class MockProvider implements AIImageProvider {
  private readonly PLACEHOLDER_COLORS = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
  ];

  constructor() {
    console.log('ðŸŽ­ Mock AI Provider initialized - using placeholder images');
  }

  getName(): string {
    return 'mock';
  }

  async generateImage(
    prompt: string, 
    config: ImageGenerationConfig = {}
  ): Promise<ImageGenerationResponse> {
    try {
      // Simulate API delay for realistic testing
      await this.simulateDelay(5000, 10000);

      const numberOfImages = config.numberOfImages || 1;
      const mimeType = config.outputMimeType || 'image/jpeg';
      const aspectRatio = config.aspectRatio || '1:1';

      // Generate mock images
      const generatedImages: GeneratedImageData[] = [];

      for (let i = 0; i < numberOfImages; i++) {
        const imageBytes = this.generatePlaceholderImage(
          prompt, 
          aspectRatio, 
          i
        );

        generatedImages.push({
          imageBytes,
          mimeType,
        });
      }

      console.log(`ðŸŽ­ Mock Provider: Generated ${numberOfImages} placeholder image(s) for prompt: "${prompt}"`);

      return {
        success: true,
        generatedImages,
      };

    } catch (error) {
      console.error('Mock provider error:', error);
      return {
        success: false,
        error: `Mock provider error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  private async simulateDelay(minMs: number, maxMs: number): Promise<void> {
    const delay = Math.random() * (maxMs - minMs) + minMs;
    return new Promise(resolve => setTimeout(resolve, delay));
  }

  private generatePlaceholderImage(
    prompt: string, 
    aspectRatio: string, 
    index: number
  ): string {
    // Calculate dimensions based on aspect ratio
    const { width, height } = this.getImageDimensions(aspectRatio);
    
    // Create a simple SVG placeholder
    const color = this.PLACEHOLDER_COLORS[index % this.PLACEHOLDER_COLORS.length] || '#FF6B6B';
    const textColor = this.getContrastColor(color);
    
    // Truncate prompt for display
    const displayPrompt = prompt.length > 30 ? prompt.substring(0, 30) + '...' : prompt;
    
    const svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <rect width="100%" height="100%" fill="${color}"/>
        <text x="50%" y="40%" dominant-baseline="middle" text-anchor="middle" 
              fill="${textColor}" font-family="Arial, sans-serif" font-size="16" font-weight="bold">
          ðŸŽ­ MOCK IMAGE
        </text>
        <text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" 
              fill="${textColor}" font-family="Arial, sans-serif" font-size="12">
          ${displayPrompt}
        </text>
        <text x="50%" y="70%" dominant-baseline="middle" text-anchor="middle" 
              fill="${textColor}" font-family="Arial, sans-serif" font-size="10" opacity="0.8">
          ${width} Ã— ${height} â€¢ ${aspectRatio}
        </text>
        <text x="50%" y="85%" dominant-baseline="middle" text-anchor="middle" 
              fill="${textColor}" font-family="Arial, sans-serif" font-size="8" opacity="0.6">
          Generated by Mock Provider #${index + 1}
        </text>
      </svg>
    `;

    // Convert SVG to base64
    return Buffer.from(svg).toString('base64');
  }

  private getImageDimensions(aspectRatio: string): { width: number; height: number } {
    // Standard dimensions for different aspect ratios
    const ratios: Record<string, { width: number; height: number }> = {
      '1:1': { width: 512, height: 512 },
      '16:9': { width: 768, height: 432 },
      '9:16': { width: 432, height: 768 },
      '4:3': { width: 640, height: 480 },
      '3:4': { width: 480, height: 640 },
      '3:2': { width: 600, height: 400 },
      '2:3': { width: 400, height: 600 },
    };

    return ratios[aspectRatio] || ratios['1:1']!;
  }

  private getContrastColor(hexColor: string): string {
    // Simple contrast color calculation
    const color = hexColor.replace('#', '');
    const r = parseInt(color.substring(0, 2), 16);
    const g = parseInt(color.substring(2, 4), 16);
    const b = parseInt(color.substring(4, 6), 16);
    
    // Calculate brightness
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    
    return brightness > 128 ? '#000000' : '#FFFFFF';
  }
} 